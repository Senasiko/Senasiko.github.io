<html><head><title>标题</title><link href="/static/css/app.css" rel="stylesheet"/><link href="/static/css/react.main.css" rel="stylesheet"/><link href="/static/css/markdown.css" rel="stylesheet"/><link href="/static/css/main.css" rel="stylesheet"/><script src="/static/js/jquery-3.3.1.min.js"></script><script src="/static/js/router.js"></script><script src="/static/js/react.main.js"></script><script src="/static/js/vue.manifest.js"></script><script src="/static/js/vue.vendor.js"></script><script src="/static/js/vue.app.js"></script><script type="text/javascript">$(document).ready(function() {
  var list = window.vueCom.postList('#app', {
    mounted: function() {
      list.getRef().init([{"config":{"layout":"post","title":"react redux reselect 更新机制验证","description":"react redux reselect 更新机制验证","share":true,"tags":["react","redux","reselect","vue","observer"],"date":"2018-01-29"},"content":"<p>react 本身更新数组和对象，类似于 array.push() 时，是否重新渲染组件呢？ <br/>react + redux 呢？  <br/>react + redux + reselect 呢？   </p>\n\n<h2>react</h2>\n\n<h3>更新 state</h3>\n\n<p>因 <code>react component</code> 更新状态的方式为 <code>this.setState()</code>, 所以每次都会重新渲染，不过不改变引用的情况下，新老状态值会保持一致\n<code></code>`javascript\n  class Parent extends Component {\n    constructor() {\n      super();\n      this.state = {\n        toDoListObj: {\n          toDoList: []\n        }\n      }\n    }\n    shouldComponentUpdate(nextProps, nextState) {\n      console.log(this.state.toDoListObj === nextState.toDoListObj);\n    }\n    componentWillUpdate() {\n      console.log(&#39;parent component will update&#39;);\n    }\n    addToDoList() {\n      const { toDoListObj } = this.state;\n      toDoListObj.toDoList.push(&#39;1&#39;);\n      console.log(&#39;addToDoList&#39;, toDoListObj);\n      this.setState({\n        toDoListObj\n      })\n    }\n    render() {\n      console.log(&#39;parent component render&#39;);\n      return (\n        &lt;div &gt;\n          &lt;h3&gt; Parent &lt;/h3&gt;\n          &lt;button\n            onClick={this.addToDoList.bind(this)}\n          &gt;add&lt;/button&gt;\n          &lt;div&gt;\n            {\n              this.state.toDoListObj.toDoList.map(\n                item =&gt; (\n                  &lt;span&gt;item&lt;/span&gt;\n                )\n              )\n            }\n          &lt;/div&gt;\n        &lt;/div&gt;\n      );\n    }\n  }</p>\n\n<p>  export default Parent;</p>\n\n<p><code></code>`\n&lt;div  align=&quot;center&quot;&gt;  <br/>  &lt;img src=&quot;../images/react-update/react-update-state.png&quot; alt=&quot;react-update-state&quot;&gt;\n&lt;/div&gt;</p>\n\n<h3>prop 更新</h3>\n\n<p>当 <code>children component</code> 为 <code>PureComponent</code> 时，父组件状态修改但不更改引用，父组件重新渲染，子组件会执行 <code>componentWillReceiveProps</code> 但不会重新渲染，但是这个时候 <code>setState({state: newState})</code> 会重新渲染。\n<code></code>`javascript\n  import React, { PureComponent } from &#39;react&#39;;</p>\n\n<p>  class Children extends PureComponent {\n    constructor(props) {\n      super(props);\n      this.state = {\n        toDoList: this.props.toDoList\n      }\n    }\n    componentWillReceiveProps(nextProps) {\n      console.log(&#39;children component will receive props&#39;,\n      this.props.toDoList === nextProps.toDoList);\n      this.setState({\n        toDoList: nextProps.toDoList\n      })\n    }\n    render() {\n      console.log(&#39;children component render&#39;, this.props);\n      return (\n        &lt;div &gt;\n          &lt;h3&gt; Children &lt;/h3&gt;\n          &lt;div&gt;\n            {\n              this.state.toDoList.map(\n                (item, index) =&gt; (\n                  &lt;span key={index}&gt;{ item }&lt;/span&gt;\n                )\n              )\n            }\n          &lt;/div&gt;\n        &lt;/div&gt;\n      );\n    }\n  }</p>\n\n<p>  export default Children;\n<code></code>` <br/>&lt;div  align=&quot;center&quot;&gt;  <br/>  &lt;img src=&quot;../images/react-update/prop-update.png&quot; alt=&quot;prop-update&quot;&gt;\n&lt;/div&gt;</p>\n\n<h2>react + redux</h2>\n\n<p>redux 状态更新之后，会执行所有的 <code>mapStateToProps</code>，然后浅比较更新前后的 <code>props</code> 是否一致， 如果一致，那么就不更新组件( <code>componentWillReceiveProps</code> 也不会执行 )。\n<code></code>`javascript\nimport React, { Component } from &#39;react&#39;;\nimport { connect } from &#39;react-redux&#39;;</p>\n\n<p>class Children extends Component {\nconstructor(props) {\n  super(props);\n  this.state = {\n    toDoList: this.props.toDoList\n  }\n}\ncomponentWillReceiveProps(nextProps) {\n  console.log(&#39;children component will receive props&#39;,\n  this.props.toDoList === nextProps.toDoList);\n  this.setState({\n    toDoList: nextProps.toDoList\n  })\n}\nrender() {\n  console.log(&#39;children component render&#39;, this.props);\n  return (\n    &lt;div &gt;\n      &lt;h3&gt; Children &lt;/h3&gt;\n      &lt;div&gt;\n        {\n          this.state.toDoList.map(\n            (item, index) =&gt; (\n              &lt;span key={index}&gt;{ item }&lt;/span&gt;\n            )\n          )\n        }\n      &lt;/div&gt;\n    &lt;/div&gt;\n  );\n}\n}</p>\n\n<p>export default connect(\nstate =&gt; {\n  console.log(&#39;state from redux&#39;, state);\n  return {\n    toDoList: state.toDoList\n  }\n}\n)(Children);</p>\n\n<p><code></code>` <br/>&lt;div  align=&quot;center&quot;&gt;  <br/>  &lt;img src=&quot;../images/react-update/redux-update.png&quot; alt=&quot;redux-update&quot;&gt;\n&lt;/div&gt;</p>\n\n<h3>react + redux + reselect</h3>\n\n<p>当 <code>redux state</code> 改变，会执行所有的 <code>mapStateToProps</code>，执行 <code>createSelector</code> 中的 <code>state array</code>，这里面的值没有改变时，直接返回上次的值，如果更新，执行 <code>selector</code>， 然后 <code>redux</code> 会再进行一次检查。\n<code>javascript\nexport const getToDoList = createSelector(\n  [state =&gt; {\n    console.log(&#39;in state&#39;);\n    return state.toDoList;\n  }],\n  toDoList =&gt; {\n    console.log(&#39;in selector&#39;);\n    return toDoList;\n  }\n)\n// in Children component\nexport default connect(\n  state =&gt; {\n    console.log(&#39;state from redux&#39;, state);\n    let toDoList = getToDoList(state);\n    console.log(&#39;from selector&#39;, toDoList);\n    return {\n      toDoList\n    }\n  }\n)(Children);\n</code>\n&lt;div  align=&quot;center&quot;&gt;  <br/>  &lt;img src=&quot;../images/react-update/selector-update.png&quot; alt=&quot;selector-update&quot;&gt;\n&lt;/div&gt;</p>\n\n<p><strong>* P.S.I 一句话总结：<code>react</code> 中所有的检查均为浅检查，即仅检查指针是否改变（标准的 js 检查） </strong>*</p>\n\n<h2>Vue 相关总结</h2>\n\n<p>vue 采用 <code>observer</code> (观察者模式) 的方式决定是否渲染组件。\n1. 遍历 <code>data</code> 和 <code>vuex state</code> 并为每个定义好的值添加 <code>observer</code> (即使是嵌套也添加)。\n2. 当有 <code>observer</code> 的值改变时，重新渲染组件。\n3. 执行到 <code>computed</code> 和 <code>getters</code> 的时候，用到哪个变量(即执行某个变量的 <code>get()</code> )，就往他的 <code>observer</code> 中注册事件，当此变量变化时，再重新执行 <code>computed</code> 和 <code>getters</code>(此过程为根据现象推测)。\n4. vue 组件默认为类似 <code>PureComponent</code>。</p>","date":"2018-01-29","postName":"react-update","postUrl":"/posts/2018/01/29/react-update"}]);
    }
  });

  var userMsg = window.vueCom.userMsg('#userMsg', {
      data: {
        name: 'sena',
        img: '/static/img/user.png',
        birthday: ''
      }
    })

  var pagination = window.reactCom.pagination('#pagination', {
    defaultCurrent: 8,
    total: 8,
    pageSize: 1
  })
});</script></head><body><div id="userMsg"></div><div class="right-container"><div id="app"></div><div id="pagination"></div></div><script>document.body.innerHeight = window.innerHeight;
document.body.innerWidth = window.innerWidth;</script></body></html>